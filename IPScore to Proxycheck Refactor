# IPQualityScore to Proxycheck.io Migration Plan

## Overview
This document outlines the migration from IPQualityScore to Proxycheck.io for IP validation services. The migration will maintain existing functionality while improving reliability and reducing costs.

## Environment Setup

### API Keys & Endpoints
```env
# Production API Key
PROXYCHECK_API_KEY=a32394-618019-a48t0t-7z9799

# Development/Public API Key
PROXYCHECK_PUBLIC_KEY=public-k82938-647649-684944

# API Endpoint
PROXYCHECK_API_ENDPOINT=https://proxycheck.io/v2
```

### API Response Comparison

#### IPQualityScore (Current)
```json
{
    "fraud_score": 85,
    "proxy": true,
    "vpn": true
}
```

#### Proxycheck.io (New)
```json
{
    "status": "ok",
    "1.1.1.1": {
        "proxy": "yes",
        "type": "VPN",
        "risk": 85
    }
}
```

## Implementation Steps

### 1. Core Validation Update (src/ipValidation.js)
Replace the current IPQualityScore implementation with Proxycheck.io:

```javascript:src/ipValidation.js
export async function validateIP(ip) {
    const API_KEY = process.env.PROXYCHECK_API_KEY || process.env.PROXYCHECK_PUBLIC_KEY;
    const response = await fetch(
        `${process.env.PROXYCHECK_API_ENDPOINT}/${ip}?key=${API_KEY}&vpn=1&risk=1`
    );
    const data = await response.json();
    
    // Handle API errors
    if (data.status !== "ok") {
        throw new Error(`Proxycheck.io API error: ${data.message}`);
    }

    const ipData = data[ip];
    return {
        isValid: ipData?.proxy !== "yes" && (ipData?.risk || 0) < 75,
        fraudScore: ipData?.risk || 0,
        isProxy: ipData?.proxy === "yes",
        isVpn: ipData?.type === "VPN"
    };
}
```

### 2. Test Suite Updates

#### Unit Tests (tests/unit/ipQualityScore.test.js)
```javascript:tests/unit/ipQualityScore.test.js
describe('IP Validation', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    test('blocks proxy IPs', async () => {
        global.fetch = jest.fn(() =>
            Promise.resolve({
                json: () => Promise.resolve({
                    status: "ok",
                    "1.1.1.1": {
                        proxy: "yes",
                        type: "VPN",
                        risk: 85
                    }
                })
            })
        );

        const result = await validateIP('1.1.1.1');
        expect(result.isValid).toBe(false);
    });

    test('allows legitimate IPs', async () => {
        global.fetch = jest.fn(() =>
            Promise.resolve({
                json: () => Promise.resolve({
                    status: "ok",
                    "1.1.1.1": {
                        proxy: "no",
                        risk: 0
                    }
                })
            })
        );

        const result = await validateIP('1.1.1.1');
        expect(result.isValid).toBe(true);
    });
});
```

#### E2E Tests (cypress/support/commands.js)
```javascript:cypress/support/commands.js
Cypress.Commands.add('mockGoodIP', () => {
    cy.intercept('GET', '**/proxycheck.io/v2/**', {
        statusCode: 200,
        body: {
            status: "ok",
            "1.1.1.1": {
                proxy: "no",
                risk: 0
            }
        }
    }).as('ipCheck');
});

Cypress.Commands.add('mockBadIP', () => {
    cy.intercept('GET', '**/proxycheck.io/v2/**', {
        statusCode: 200,
        body: {
            status: "ok",
            "1.1.1.1": {
                proxy: "yes",
                type: "VPN",
                risk: 85
            }
        }
    }).as('ipCheck');
});
```

### 3. Frontend Integration (consultation.html)
Update CSP headers and error messages:

```html:consultation.html
<meta http-equiv="Content-Security-Policy" content="
    connect-src 'self' https://api.ipify.org https://proxycheck.io https://script.google.com;
    // ... rest of CSP ...
">
```

### 4. Rate Limiting & Error Handling
- Free tier: 1,000 requests per day
- Implement exponential backoff for retries
- Cache results for repeated checks of the same IP

```javascript:src/ipValidation.js
const cache = new Map();
const CACHE_DURATION = 1000 * 60 * 60; // 1 hour

export async function validateIPWithCache(ip) {
    const cached = cache.get(ip);
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
        return cached.data;
    }

    const result = await validateIP(ip);
    cache.set(ip, {
        timestamp: Date.now(),
        data: result
    });
    return result;
}
```

## Migration Process

### Phase 1: Development
1. âœ… Set up environment variables
2. Create feature branch `feature/proxycheck-integration`
3. Implement core validation changes
4. Update test suites
5. Add caching layer

### Phase 2: Testing
1. Run unit tests
2. Run E2E tests
3. Manual testing with actual VPNs
4. Load testing with sample traffic

### Phase 3: Deployment
1. Deploy to staging
2. Monitor error rates
3. Deploy to production
4. Keep IPQualityScore as fallback for 1 week

### Phase 4: Monitoring
1. Set up alerts for rate limits
2. Monitor API response times
3. Track false positive/negative rates

## Rollback Plan
If issues are detected:
1. Revert to IPQualityScore branch
2. Update DNS settings if necessary
3. Analyze Proxycheck.io issues

## Success Metrics
1. API response time < 300ms
2. False positive rate < 1%
3. Uptime > 99.9%
4. Cost reduction > 30%

Would you like me to proceed with implementing any specific part of this plan?